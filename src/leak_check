#!/usr/bin/env python3

# NOTE: Valgrind doesn't report a leaked file descriptor as an error, and memory
# leaks are reported as errors only if '--leak-check=full' is enabled.
# Therefore, we wrap Valgrind and parse its output to determine if there are any
# file descriptor or memory leaks.

import optparse
import os.path
import re
import subprocess
import sys

fd_regex = re.compile('FILE DESCRIPTORS: (\d)+ open at exit.')
mem_regex = re.compile('in use at exit: 0 bytes in 0 blocks')

def check(prog):
    other_error = False
    fd_match = False
    fd_leak = False
    mem_no_leak = False
    exec_prog = prog
    if not os.path.isabs(exec_prog):
        exec_prog = os.path.join('.', exec_prog)
    args = 'valgrind --error-exitcode=1 --track-fds=yes --leak-check=summary ' + exec_prog
    args = args.split()
    proc = subprocess.Popen(args, stderr=subprocess.PIPE)
    out = proc.stderr.readlines()
    for line in out:
        line = line.decode()
        if not fd_match:
            match = fd_regex.search(line)
            if match:
                fd_match = True
                if match.group(1) != '3': # stdin, stdout, stderr
                    fd_leak = True
                continue
        if not mem_no_leak:
            match = mem_regex.search(line)
            if match:
                mem_no_leak = True
                continue
    if not fd_match:
        eprint('failed to match file descriptor summary')
    elif fd_leak:
        eprint('detected file descriptor leak')
    if not mem_no_leak:
        eprint('detected memory leak')
    proc.wait()
    ret = proc.returncode
    if ret != 0:
        other_error = True
        eprint('detected unspecified error')
    return fd_leak or not mem_no_leak or other_error

def eprint(s):
    print('*** ' + s, file = sys.stderr)
    sys.stderr.flush()

def main():
    # Parse command line.
    excluded_progs={}
    def exclude_cb(option, opt, value, parser):
        excluded_progs[value] = True
    parser = optparse.OptionParser()
    parser.add_option('--exclude', type='string', action='callback', callback=exclude_cb)
    (options, args) = parser.parse_args()
    # Run all checks.
    num_fails = 0
    num_runs = 0
    for prog in args:
        if prog in excluded_progs:
            continue
        print(prog)
        sys.stdout.flush()
        leak = check(prog)
        if leak:
            num_fails += 1
        num_runs += 1
    if num_fails > 0:
        s = '%d OF %d CHECKS FAILED' % (num_fails, num_runs);
        print(len(s) * '=')
        print(s)
        print(len(s) * '=')
        return 1
    print('===========================')
    print('NO LEAKS OR ERRORS DETECTED')
    print('===========================')
    return 0
         
if __name__ == '__main__':
    sys.exit(main())

